# logic/turnover_processor.py
# Responsabilidade: Processar e analisar dados de rotatividade (turnover) de colaboradores.

import hashlib
from datetime import datetime
from typing import Dict, List
import logging

from models.analysis import AnalysisResult, ValidationResult
from models.enums import AnalysisType, RiskLevel, DataQuality
from config.settings import AppConfig

logger = logging.getLogger(__name__)


class TurnoverProcessor:
    """
    Processa dados de turnover e calcula m√©tricas chave:
    - Taxa de turnover (mensal e anualizada)
    - Impacto financeiro total
    - An√°lise de custos por tipo (demiss√£o, contrata√ß√£o, produtividade)
    """
    
    def __init__(self):
        self.config = AppConfig()
    
    def validate(
        self,
        func_inicio: int,
        func_fim: int,
        admissoes: int,
        demissoes: int,
        periodo_meses: int
    ) -> ValidationResult:
        """
        Valida os dados de entrada antes do processamento.
        
        Args:
            func_inicio: N√∫mero de funcion√°rios no in√≠cio do per√≠odo
            func_fim: N√∫mero de funcion√°rios no fim do per√≠odo
            admissoes: N√∫mero de admiss√µes no per√≠odo
            demissoes: N√∫mero de demiss√µes no per√≠odo
            periodo_meses: Dura√ß√£o do per√≠odo em meses
        
        Returns:
            ValidationResult com status da valida√ß√£o
        """
        errors = []
        warnings = []
        suggestions = []
        
        # Valida√ß√µes b√°sicas
        if func_inicio <= 0:
            errors.append("N√∫mero de funcion√°rios no in√≠cio deve ser maior que zero")
        
        if func_fim < 0:
            errors.append("N√∫mero de funcion√°rios no fim n√£o pode ser negativo")
        
        if admissoes < 0:
            errors.append("N√∫mero de admiss√µes n√£o pode ser negativo")
        
        if demissoes < 0:
            errors.append("N√∫mero de demiss√µes n√£o pode ser negativo")
        
        if periodo_meses <= 0:
            errors.append("Per√≠odo deve ser maior que zero")
        elif periodo_meses > 24:
            warnings.append("Per√≠odo muito longo (>24 meses) - considere an√°lises anuais")
        
        # Valida√ß√£o de coer√™ncia dos dados
        if func_inicio > 0:
            expected_func_fim = func_inicio + admissoes - demissoes
            if func_fim != expected_func_fim:
                diff = abs(func_fim - expected_func_fim)
                warnings.append(
                    f"Inconsist√™ncia detectada: Funcion√°rios fim ({func_fim}) "
                    f"difere do esperado ({expected_func_fim}) por {diff} colaboradores. "
                    f"Verifique se todos os movimentos foram contabilizados."
                )
        
        # Avisos sobre movimenta√ß√£o excessiva
        if func_inicio > 0:
            movimento_total = admissoes + demissoes
            taxa_movimento = (movimento_total / func_inicio) * 100
            
            if taxa_movimento > 50:
                warnings.append(
                    f"Alta movimenta√ß√£o detectada ({taxa_movimento:.1f}% do quadro inicial)"
                )
        
        # Sugest√µes
        if admissoes == 0 and demissoes == 0:
            suggestions.append("Nenhuma movimenta√ß√£o no per√≠odo - verifique se os dados est√£o completos")
        
        # Calcula score de qualidade
        quality_score = 100
        if errors:
            quality_score = 0
        else:
            # Penaliza warnings
            quality_score -= len(warnings) * 10
            quality_score = max(quality_score, 60)  # M√≠nimo de 60 se n√£o houver erros
        
        return ValidationResult(
            is_valid=len(errors) == 0,
            errors=errors,
            warnings=warnings,
            suggestions=suggestions,
            quality_score=quality_score
        )
    
    def process(
        self,
        name: str,
        func_inicio: int,
        func_fim: int,
        admissoes: int,
        demissoes: int,
        periodo_meses: int,
        setor: str,
        custos: Dict[str, float]
    ) -> AnalysisResult:
        """
        Processa os dados de turnover e calcula todas as m√©tricas.
        
        Args:
            name: Nome da an√°lise
            func_inicio: Funcion√°rios no in√≠cio do per√≠odo
            func_fim: Funcion√°rios no fim do per√≠odo
            admissoes: Total de admiss√µes
            demissoes: Total de demiss√µes
            periodo_meses: Dura√ß√£o do per√≠odo em meses
            setor: Setor da empresa (para benchmark)
            custos: Dicion√°rio com custos unit√°rios {
                'demissao': float,
                'contratacao': float,
                'produtividade': float
            }
        
        Returns:
            AnalysisResult com os resultados da an√°lise
        """
        # Valida os dados
        validation = self.validate(func_inicio, func_fim, admissoes, demissoes, periodo_meses)
        if not validation.is_valid:
            raise ValueError(f"Dados inv√°lidos: {'; '.join(validation.errors)}")
        
        # Calcula m√©dia de funcion√°rios no per√≠odo
        media_funcionarios = (func_inicio + func_fim) / 2
        
        # Calcula taxa de turnover no per√≠odo
        # F√≥rmula: ((Admiss√µes + Demiss√µes) / 2) / M√©dia de funcion√°rios * 100
        if media_funcionarios > 0:
            taxa_periodo = ((admissoes + demissoes) / 2) / media_funcionarios * 100
        else:
            taxa_periodo = 0
        
        # Anualiza a taxa (projeta para 12 meses)
        taxa_anualizada = taxa_periodo * (12 / periodo_meses)
        
        # Calcula custos detalhados
        custo_demissoes = demissoes * custos.get('demissao', 0)
        custo_contratacoes = admissoes * custos.get('contratacao', 0)
        
        # Custo de produtividade (apenas para posi√ß√µes que foram substitu√≠das)
        substituicoes = min(admissoes, demissoes)
        custo_produtividade = substituicoes * custos.get('produtividade', 0)
        
        # Impacto financeiro total
        impacto_total = custo_demissoes + custo_contratacoes + custo_produtividade
        
        # Custo por funcion√°rio m√©dio
        custo_por_funcionario = impacto_total / media_funcionarios if media_funcionarios > 0 else 0
        
        # Determina n√≠vel de risco
        benchmark = self.config.get_benchmark_turnover(setor)
        risk_level = self._calculate_risk_level(taxa_anualizada, benchmark)
        
        # Gera insights autom√°ticos
        insights = self._generate_insights(
            taxa_anualizada,
            benchmark,
            admissoes,
            demissoes,
            impacto_total,
            media_funcionarios
        )
        
        # Cria detalhamento de custos para exibi√ß√£o
        custos_detalhados = {
            'Demiss√µes': custo_demissoes,
            'Contrata√ß√µes': custo_contratacoes,
            'Perda de Produtividade': custo_produtividade
        }
        
        return AnalysisResult(
            id=hashlib.md5(f"turnover_{datetime.now()}".encode()).hexdigest()[:8],
            type=AnalysisType.TURNOVER,
            name=name,
            timestamp=datetime.now(),
            data={
                'taxa_turnover_periodo': round(taxa_periodo, 2),
                'taxa_turnover_anual': round(taxa_anualizada, 2),
                'impacto_financeiro': round(impacto_total, 2),
                'custo_por_funcionario': round(custo_por_funcionario, 2),
                'custos_detalhados': custos_detalhados,
                'substituicoes': substituicoes
            },
            metadata={
                'func_inicio': func_inicio,
                'func_fim': func_fim,
                'media_funcionarios': round(media_funcionarios, 1),
                'admissoes': admissoes,
                'demissoes': demissoes,
                'periodo_meses': periodo_meses,
                'setor': setor,
                'benchmark_setor': benchmark
            },
            quality=validation.quality,
            risk_level=risk_level,
            insights=insights
        )
    
    def _calculate_risk_level(self, taxa: float, benchmark: float) -> RiskLevel:
        """Determina o n√≠vel de risco baseado na compara√ß√£o com o benchmark."""
        if taxa > benchmark * 1.5:
            return RiskLevel.HIGH
        elif taxa > benchmark * 1.3:
            return RiskLevel.MODERATE
        else:
            return RiskLevel.LOW
    
    def _generate_insights(
        self,
        taxa: float,
        benchmark: float,
        admissoes: int,
        demissoes: int,
        impacto_total: float,
        media_funcionarios: float
    ) -> List[str]:
        """Gera insights autom√°ticos baseados nos dados."""
        insights = []
        
        # Insight sobre a taxa
        diff = taxa - benchmark
        if diff > benchmark * 0.5:  # 50% acima
            insights.append(
                f"üö® Taxa de turnover cr√≠tica: {diff:.1f}% acima do benchmark do setor ({benchmark:.1f}%)"
            )
        elif diff > 0:
            insights.append(
                f"‚ö†Ô∏è Taxa de turnover {diff:.1f}% acima do benchmark do setor ({benchmark:.1f}%)"
            )
        else:
            insights.append(
                f"‚úÖ Taxa de turnover dentro dos par√¢metros do setor"
            )
        
        # Insight sobre balan√ßo de movimenta√ß√£o
        saldo = admissoes - demissoes
        if saldo > 0:
            percentual_crescimento = (saldo / media_funcionarios) * 100
            insights.append(
                f"üìà Crescimento do quadro: {saldo} colaboradores ({percentual_crescimento:.1f}%)"
            )
        elif saldo < 0:
            percentual_reducao = abs(saldo / media_funcionarios) * 100
            insights.append(
                f"üìâ Redu√ß√£o do quadro: {abs(saldo)} colaboradores ({percentual_reducao:.1f}%)"
            )
        else:
            insights.append(
                f"‚öñÔ∏è Quadro est√°vel: admiss√µes e demiss√µes equilibradas"
            )
        
        # Insight sobre custo
        custo_percentual = (impacto_total / (media_funcionarios * 12000)) * 100  # Assume sal√°rio m√©dio 12k/ano
        if custo_percentual > 20:
            insights.append(
                f"üí∞ Impacto financeiro elevado: R$ {impacto_total:,.2f} "
                f"(~{custo_percentual:.1f}% da folha anual estimada)"
            )
        elif impacto_total > 100000:
            insights.append(
                f"üí∏ Impacto financeiro significativo: R$ {impacto_total:,.2f}"
            )
        
        # Insight sobre padr√£o de rotatividade
        if admissoes > 0 and demissoes > 0:
            ratio = admissoes / demissoes
            if ratio > 1.5:
                insights.append(
                    f"üîÑ Alta taxa de contrata√ß√£o: {admissoes} admiss√µes vs {demissoes} demiss√µes - "
                    f"poss√≠vel expans√£o ou dificuldade de reten√ß√£o"
                )
            elif ratio < 0.7:
                insights.append(
                    f"üìä Alta taxa de desligamento: {demissoes} demiss√µes vs {admissoes} admiss√µes - "
                    f"poss√≠vel reestrutura√ß√£o ou redu√ß√£o de custos"
                )
        
        return insights